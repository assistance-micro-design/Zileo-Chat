// Copyright 2025 Assistance Micro Design
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Sub-Agent Execution Models
//!
//! This module provides types for tracking sub-agent executions in the database.
//! Sub-agents are temporary agents spawned by a primary agent for parallel
//! or delegated task execution.
//!
//! # Overview
//!
//! When a primary agent spawns or delegates to sub-agents, each execution is
//! logged to the `sub_agent_execution` table with:
//! - Parent-child relationship tracking
//! - Execution status and timing metrics
//! - Result summary and error information
//!
//! # Sub-Agent Hierarchy Rules
//!
//! - Maximum 3 sub-agents per workflow
//! - Single level only (sub-agents cannot spawn other sub-agents)
//! - Sub-agents report ONLY to the primary agent
//! - No context/memory/state sharing between agents

use super::serde_utils::deserialize_thing_id;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Status of a sub-agent execution.
///
/// Tracks the lifecycle of a sub-agent from creation to completion.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SubAgentStatus {
    /// Sub-agent created, awaiting validation or start
    Pending,
    /// Sub-agent is currently executing its task
    Running,
    /// Sub-agent completed successfully with a report
    Completed,
    /// Sub-agent encountered an error during execution
    Error,
    /// Sub-agent was cancelled (by user or parent agent)
    Cancelled,
}

impl Default for SubAgentStatus {
    fn default() -> Self {
        Self::Pending
    }
}

impl std::fmt::Display for SubAgentStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SubAgentStatus::Pending => write!(f, "pending"),
            SubAgentStatus::Running => write!(f, "running"),
            SubAgentStatus::Completed => write!(f, "completed"),
            SubAgentStatus::Error => write!(f, "error"),
            SubAgentStatus::Cancelled => write!(f, "cancelled"),
        }
    }
}

/// Sub-agent execution record.
///
/// Tracks a single sub-agent execution including timing, metrics, and results.
/// Stored in the `sub_agent_execution` table.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubAgentExecution {
    /// Unique identifier (deserialized from SurrealDB Thing type)
    #[serde(deserialize_with = "deserialize_thing_id")]
    pub id: String,
    /// Workflow ID where this execution occurred
    pub workflow_id: String,
    /// ID of the parent (primary) agent that spawned/delegated
    pub parent_agent_id: String,
    /// ID of the sub-agent performing the task
    pub sub_agent_id: String,
    /// Human-readable name of the sub-agent
    pub sub_agent_name: String,
    /// Description of the task assigned to the sub-agent
    pub task_description: String,
    /// Current execution status
    #[serde(default)]
    pub status: SubAgentStatus,
    /// Execution duration in milliseconds
    pub duration_ms: Option<u64>,
    /// Input tokens consumed by the sub-agent
    pub tokens_input: Option<u64>,
    /// Output tokens generated by the sub-agent
    pub tokens_output: Option<u64>,
    /// Summary of the sub-agent's report (truncated for storage)
    pub result_summary: Option<String>,
    /// Error message if status is Error
    pub error_message: Option<String>,
    /// Parent execution ID for hierarchical tracing (OPT-SA-11).
    /// Links this execution to a parent execution record (e.g., batch operations).
    /// None for top-level executions.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub parent_execution_id: Option<String>,
    /// When the execution was created
    #[serde(default = "Utc::now")]
    pub created_at: DateTime<Utc>,
    /// When the execution completed (if completed)
    pub completed_at: Option<DateTime<Utc>>,
}

/// Creation payload for SubAgentExecution.
///
/// Used when creating a new sub-agent execution record.
/// ID is passed separately, datetime fields use database defaults.
#[allow(dead_code)]
#[derive(Debug, Clone, Serialize)]
pub struct SubAgentExecutionCreate {
    /// Workflow ID where this execution occurs
    pub workflow_id: String,
    /// ID of the parent agent
    pub parent_agent_id: String,
    /// ID of the sub-agent
    pub sub_agent_id: String,
    /// Name of the sub-agent
    pub sub_agent_name: String,
    /// Task description (the prompt sent to sub-agent)
    pub task_description: String,
    /// Initial status (as string for SurrealDB)
    pub status: String,
    /// Parent execution ID for hierarchical tracing (OPT-SA-11).
    /// Links to a parent execution record for correlation tracking.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parent_execution_id: Option<String>,
}

#[allow(dead_code)]
impl SubAgentExecutionCreate {
    /// Creates a new SubAgentExecutionCreate.
    ///
    /// # Arguments
    /// * `workflow_id` - The workflow where this execution occurs
    /// * `parent_agent_id` - The primary agent spawning/delegating
    /// * `sub_agent_id` - The sub-agent being executed
    /// * `sub_agent_name` - Human-readable name for the sub-agent
    /// * `task_description` - The task/prompt for the sub-agent
    pub fn new(
        workflow_id: String,
        parent_agent_id: String,
        sub_agent_id: String,
        sub_agent_name: String,
        task_description: String,
    ) -> Self {
        Self {
            workflow_id,
            parent_agent_id,
            sub_agent_id,
            sub_agent_name,
            task_description,
            status: SubAgentStatus::Pending.to_string(),
            parent_execution_id: None,
        }
    }

    /// Creates a new SubAgentExecutionCreate with a parent execution ID (OPT-SA-11).
    ///
    /// Use this method when creating a sub-execution that should be linked
    /// to a parent execution for hierarchical tracing.
    ///
    /// # Arguments
    /// * `workflow_id` - The workflow where this execution occurs
    /// * `parent_agent_id` - The primary agent spawning/delegating
    /// * `sub_agent_id` - The sub-agent being executed
    /// * `sub_agent_name` - Human-readable name for the sub-agent
    /// * `task_description` - The task/prompt for the sub-agent
    /// * `parent_execution_id` - The parent execution ID for tracing
    pub fn with_parent(
        workflow_id: String,
        parent_agent_id: String,
        sub_agent_id: String,
        sub_agent_name: String,
        task_description: String,
        parent_execution_id: Option<String>,
    ) -> Self {
        Self {
            workflow_id,
            parent_agent_id,
            sub_agent_id,
            sub_agent_name,
            task_description,
            status: SubAgentStatus::Pending.to_string(),
            parent_execution_id,
        }
    }
}

/// Update payload for completing a sub-agent execution.
///
/// Used to update the execution record when it completes.
#[allow(dead_code)]
#[derive(Debug, Clone, Serialize)]
pub struct SubAgentExecutionComplete {
    /// Final status
    pub status: String,
    /// Execution duration in milliseconds
    pub duration_ms: u64,
    /// Input tokens consumed
    pub tokens_input: Option<u64>,
    /// Output tokens generated
    pub tokens_output: Option<u64>,
    /// Summary of the result (truncated if needed)
    pub result_summary: Option<String>,
    /// Error message if failed
    pub error_message: Option<String>,
}

#[allow(dead_code)]
impl SubAgentExecutionComplete {
    /// Creates a success completion payload.
    pub fn success(
        duration_ms: u64,
        tokens_input: Option<u64>,
        tokens_output: Option<u64>,
        result_summary: String,
    ) -> Self {
        // Truncate result summary if too long (max 5000 chars for DB storage)
        // "... [truncated]" is 16 chars, so we take 5000 - 16 = 4984 chars
        const TRUNCATION_SUFFIX: &str = "... [truncated]";
        const MAX_LEN: usize = 5000;
        let suffix_len = TRUNCATION_SUFFIX.len();

        let summary = if result_summary.len() > MAX_LEN {
            format!(
                "{}{}",
                &result_summary[..MAX_LEN - suffix_len],
                TRUNCATION_SUFFIX
            )
        } else {
            result_summary
        };

        Self {
            status: SubAgentStatus::Completed.to_string(),
            duration_ms,
            tokens_input,
            tokens_output,
            result_summary: Some(summary),
            error_message: None,
        }
    }

    /// Creates an error completion payload.
    pub fn error(duration_ms: u64, error_message: String) -> Self {
        Self {
            status: SubAgentStatus::Error.to_string(),
            duration_ms,
            tokens_input: None,
            tokens_output: None,
            result_summary: None,
            error_message: Some(error_message),
        }
    }

    /// Creates a cancelled completion payload.
    pub fn cancelled(duration_ms: u64) -> Self {
        Self {
            status: SubAgentStatus::Cancelled.to_string(),
            duration_ms,
            tokens_input: None,
            tokens_output: None,
            result_summary: None,
            error_message: Some("Execution cancelled".to_string()),
        }
    }
}

/// Metrics from a sub-agent execution.
///
/// Returned as part of the tool result to the primary agent.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubAgentMetrics {
    /// Execution duration in milliseconds
    pub duration_ms: u64,
    /// Input tokens consumed
    pub tokens_input: u64,
    /// Output tokens generated
    pub tokens_output: u64,
}

/// Result of a sub-agent spawn operation.
///
/// Returned by SpawnAgentTool after successful execution.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubAgentSpawnResult {
    /// Whether the spawn was successful
    pub success: bool,
    /// ID of the spawned sub-agent
    pub child_id: String,
    /// Markdown report from the sub-agent
    pub report: String,
    /// Execution metrics
    pub metrics: SubAgentMetrics,
}

/// Result of a delegate operation.
///
/// Returned by DelegateTaskTool after successful delegation.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DelegateResult {
    /// Whether the delegation was successful
    pub success: bool,
    /// ID of the delegated-to agent
    pub agent_id: String,
    /// Markdown report from the agent
    pub report: String,
    /// Execution metrics
    pub metrics: SubAgentMetrics,
}

/// Result of a parallel batch execution.
///
/// Returned by ParallelTasksTool after executing multiple tasks.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParallelBatchResult {
    /// Whether all tasks completed successfully
    pub success: bool,
    /// Number of tasks that completed successfully
    pub completed: usize,
    /// Number of tasks that failed
    pub failed: usize,
    /// Individual results for each task
    pub results: Vec<ParallelTaskResult>,
    /// Aggregated report from all tasks
    pub aggregated_report: String,
}

/// Result of a single task in a parallel batch.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ParallelTaskResult {
    /// Agent ID that executed the task
    pub agent_id: String,
    /// Whether this task succeeded
    pub success: bool,
    /// Report from the agent (if successful)
    pub report: Option<String>,
    /// Error message (if failed)
    pub error: Option<String>,
    /// Execution metrics (if available)
    pub metrics: Option<SubAgentMetrics>,
}

/// Constants for sub-agent system.
#[allow(dead_code)]
pub mod constants {
    /// Maximum number of sub-agents per workflow
    pub const MAX_SUB_AGENTS: usize = 3;

    /// Maximum length for task descriptions in database
    pub const MAX_TASK_DESCRIPTION_LEN: usize = 10000;

    /// Maximum length for result summaries in database
    pub const MAX_RESULT_SUMMARY_LEN: usize = 5000;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_sub_agent_status_serialization() {
        let status = SubAgentStatus::Running;
        let json = serde_json::to_string(&status).unwrap();
        assert_eq!(json, "\"running\"");

        let deserialized: SubAgentStatus = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized, SubAgentStatus::Running);
    }

    #[test]
    fn test_sub_agent_status_display() {
        assert_eq!(SubAgentStatus::Pending.to_string(), "pending");
        assert_eq!(SubAgentStatus::Running.to_string(), "running");
        assert_eq!(SubAgentStatus::Completed.to_string(), "completed");
        assert_eq!(SubAgentStatus::Error.to_string(), "error");
        assert_eq!(SubAgentStatus::Cancelled.to_string(), "cancelled");
    }

    #[test]
    fn test_sub_agent_execution_create() {
        let create = SubAgentExecutionCreate::new(
            "wf_001".to_string(),
            "parent_agent".to_string(),
            "sub_agent_001".to_string(),
            "Analysis Sub-Agent".to_string(),
            "Analyze the database schema".to_string(),
        );

        assert_eq!(create.workflow_id, "wf_001");
        assert_eq!(create.parent_agent_id, "parent_agent");
        assert_eq!(create.sub_agent_id, "sub_agent_001");
        assert_eq!(create.status, "pending");
    }

    #[test]
    fn test_sub_agent_execution_complete_success() {
        let complete = SubAgentExecutionComplete::success(
            1500,
            Some(100),
            Some(500),
            "Analysis complete. Found 5 tables.".to_string(),
        );

        assert_eq!(complete.status, "completed");
        assert_eq!(complete.duration_ms, 1500);
        assert!(complete.result_summary.is_some());
        assert!(complete.error_message.is_none());
    }

    #[test]
    fn test_sub_agent_execution_complete_error() {
        let complete = SubAgentExecutionComplete::error(500, "Connection timeout".to_string());

        assert_eq!(complete.status, "error");
        assert_eq!(complete.duration_ms, 500);
        assert!(complete.result_summary.is_none());
        assert_eq!(
            complete.error_message,
            Some("Connection timeout".to_string())
        );
    }

    #[test]
    fn test_sub_agent_execution_complete_truncates_long_summary() {
        let long_summary = "x".repeat(6000);
        let complete = SubAgentExecutionComplete::success(1000, Some(100), Some(200), long_summary);

        let summary = complete.result_summary.unwrap();
        assert!(summary.len() <= 5000);
        assert!(summary.ends_with("... [truncated]"));
    }

    #[test]
    fn test_sub_agent_spawn_result_serialization() {
        let result = SubAgentSpawnResult {
            success: true,
            child_id: "sub_001".to_string(),
            report: "# Analysis Report\n\nFound 3 issues.".to_string(),
            metrics: SubAgentMetrics {
                duration_ms: 2000,
                tokens_input: 150,
                tokens_output: 300,
            },
        };

        let json = serde_json::to_string(&result).unwrap();
        assert!(json.contains("\"success\":true"));
        assert!(json.contains("\"child_id\":\"sub_001\""));
        assert!(json.contains("\"duration_ms\":2000"));
    }

    #[test]
    fn test_parallel_batch_result() {
        let result = ParallelBatchResult {
            success: true,
            completed: 3,
            failed: 0,
            results: vec![ParallelTaskResult {
                agent_id: "agent_1".to_string(),
                success: true,
                report: Some("Report 1".to_string()),
                error: None,
                metrics: Some(SubAgentMetrics {
                    duration_ms: 1000,
                    tokens_input: 100,
                    tokens_output: 200,
                }),
            }],
            aggregated_report: "# Combined Report\n\n3 tasks completed.".to_string(),
        };

        let json = serde_json::to_string(&result).unwrap();
        assert!(json.contains("\"completed\":3"));
        assert!(json.contains("\"failed\":0"));
    }

    #[test]
    fn test_max_sub_agents_constant() {
        assert_eq!(constants::MAX_SUB_AGENTS, 3);
    }

    // OPT-SA-11: Tests for parent_execution_id (Correlation ID for Hierarchical Tracing)

    #[test]
    fn test_sub_agent_execution_create_with_parent() {
        let parent_id = "parent_exec_001".to_string();
        let create = SubAgentExecutionCreate::with_parent(
            "wf_001".to_string(),
            "parent_agent".to_string(),
            "sub_agent_001".to_string(),
            "Analysis Sub-Agent".to_string(),
            "Analyze the database schema".to_string(),
            Some(parent_id.clone()),
        );

        assert_eq!(create.workflow_id, "wf_001");
        assert_eq!(create.parent_agent_id, "parent_agent");
        assert_eq!(create.sub_agent_id, "sub_agent_001");
        assert_eq!(create.status, "pending");
        assert_eq!(create.parent_execution_id, Some(parent_id));
    }

    #[test]
    fn test_sub_agent_execution_create_with_parent_none() {
        let create = SubAgentExecutionCreate::with_parent(
            "wf_001".to_string(),
            "parent_agent".to_string(),
            "sub_agent_001".to_string(),
            "Analysis Sub-Agent".to_string(),
            "Analyze the database schema".to_string(),
            None,
        );

        assert_eq!(create.parent_execution_id, None);
    }

    #[test]
    fn test_sub_agent_execution_create_new_has_no_parent() {
        let create = SubAgentExecutionCreate::new(
            "wf_001".to_string(),
            "parent_agent".to_string(),
            "sub_agent_001".to_string(),
            "Analysis Sub-Agent".to_string(),
            "Analyze the database schema".to_string(),
        );

        assert_eq!(create.parent_execution_id, None);
    }

    #[test]
    fn test_sub_agent_execution_create_with_parent_serialization() {
        let create = SubAgentExecutionCreate::with_parent(
            "wf_001".to_string(),
            "parent_agent".to_string(),
            "sub_agent_001".to_string(),
            "Analysis Sub-Agent".to_string(),
            "Task description".to_string(),
            Some("parent_exec_001".to_string()),
        );

        let json = serde_json::to_string(&create).unwrap();
        assert!(json.contains("\"parent_execution_id\":\"parent_exec_001\""));
    }

    #[test]
    fn test_sub_agent_execution_create_without_parent_serialization_skip() {
        let create = SubAgentExecutionCreate::new(
            "wf_001".to_string(),
            "parent_agent".to_string(),
            "sub_agent_001".to_string(),
            "Analysis Sub-Agent".to_string(),
            "Task description".to_string(),
        );

        let json = serde_json::to_string(&create).unwrap();
        // parent_execution_id should be skipped when None due to skip_serializing_if
        assert!(!json.contains("parent_execution_id"));
    }
}
