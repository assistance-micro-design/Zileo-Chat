// Copyright 2025 Zileo-Chat-3 Contributors
// SPDX-License-Identifier: Apache-2.0

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

/// Workflow status representing the current state of a workflow
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum WorkflowStatus {
    Idle,
    Running,
    Completed,
    Error,
}

/// Workflow entity representing a user workflow
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Workflow {
    /// Unique identifier
    pub id: String,
    /// Workflow name
    pub name: String,
    /// Associated agent ID
    pub agent_id: String,
    /// Current status
    pub status: WorkflowStatus,
    /// Creation timestamp (set by database)
    #[serde(default = "Utc::now")]
    pub created_at: DateTime<Utc>,
    /// Last update timestamp (set by database)
    #[serde(default = "Utc::now")]
    pub updated_at: DateTime<Utc>,
    /// Completion timestamp (if completed)
    #[serde(default)]
    pub completed_at: Option<DateTime<Utc>>,
}

/// Workflow creation payload - only fields needed for creation
/// Datetime fields are handled by database defaults
#[derive(Debug, Clone, Serialize)]
pub struct WorkflowCreate {
    /// Unique identifier
    pub id: String,
    /// Workflow name
    pub name: String,
    /// Associated agent ID
    pub agent_id: String,
    /// Current status
    pub status: WorkflowStatus,
}

/// Result of a workflow execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkflowResult {
    /// Markdown report generated by the agent
    pub report: String,
    /// Execution metrics
    pub metrics: WorkflowMetrics,
    /// List of tools used during execution
    pub tools_used: Vec<String>,
    /// List of MCP calls made during execution
    pub mcp_calls: Vec<String>,
}

/// Metrics collected during workflow execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WorkflowMetrics {
    /// Duration in milliseconds
    pub duration_ms: u64,
    /// Input tokens consumed
    pub tokens_input: usize,
    /// Output tokens generated
    pub tokens_output: usize,
    /// Cost in USD
    pub cost_usd: f64,
    /// LLM provider used
    pub provider: String,
    /// Model used
    pub model: String,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_workflow_status_serialization() {
        let status = WorkflowStatus::Running;
        let json = serde_json::to_string(&status).unwrap();
        assert_eq!(json, "\"running\"");

        let deserialized: WorkflowStatus = serde_json::from_str(&json).unwrap();
        assert!(matches!(deserialized, WorkflowStatus::Running));
    }

    #[test]
    fn test_workflow_status_all_variants() {
        let variants = vec![
            (WorkflowStatus::Idle, "\"idle\""),
            (WorkflowStatus::Running, "\"running\""),
            (WorkflowStatus::Completed, "\"completed\""),
            (WorkflowStatus::Error, "\"error\""),
        ];

        for (status, expected_json) in variants {
            let json = serde_json::to_string(&status).unwrap();
            assert_eq!(json, expected_json);
        }
    }

    #[test]
    fn test_workflow_serialization() {
        let workflow = Workflow {
            id: "wf_001".to_string(),
            name: "Test Workflow".to_string(),
            agent_id: "agent_001".to_string(),
            status: WorkflowStatus::Idle,
            created_at: Utc::now(),
            updated_at: Utc::now(),
            completed_at: None,
        };

        let json = serde_json::to_string(&workflow).unwrap();
        let deserialized: Workflow = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.id, workflow.id);
        assert_eq!(deserialized.name, workflow.name);
        assert_eq!(deserialized.agent_id, workflow.agent_id);
    }

    #[test]
    fn test_workflow_result_serialization() {
        let result = WorkflowResult {
            report: "# Report\n\nTask completed.".to_string(),
            metrics: WorkflowMetrics {
                duration_ms: 1500,
                tokens_input: 100,
                tokens_output: 200,
                cost_usd: 0.005,
                provider: "Mistral".to_string(),
                model: "mistral-large".to_string(),
            },
            tools_used: vec!["tool1".to_string(), "tool2".to_string()],
            mcp_calls: vec!["mcp_call1".to_string()],
        };

        let json = serde_json::to_string(&result).unwrap();
        let deserialized: WorkflowResult = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.report, result.report);
        assert_eq!(deserialized.metrics.duration_ms, result.metrics.duration_ms);
        assert_eq!(deserialized.tools_used.len(), 2);
        assert_eq!(deserialized.mcp_calls.len(), 1);
    }

    #[test]
    fn test_workflow_metrics_serialization() {
        let metrics = WorkflowMetrics {
            duration_ms: 2500,
            tokens_input: 150,
            tokens_output: 300,
            cost_usd: 0.01,
            provider: "Ollama".to_string(),
            model: "llama3".to_string(),
        };

        let json = serde_json::to_string(&metrics).unwrap();
        let deserialized: WorkflowMetrics = serde_json::from_str(&json).unwrap();

        assert_eq!(deserialized.duration_ms, metrics.duration_ms);
        assert_eq!(deserialized.tokens_input, metrics.tokens_input);
        assert_eq!(deserialized.tokens_output, metrics.tokens_output);
        assert!((deserialized.cost_usd - metrics.cost_usd).abs() < f64::EPSILON);
        assert_eq!(deserialized.provider, metrics.provider);
        assert_eq!(deserialized.model, metrics.model);
    }
}
