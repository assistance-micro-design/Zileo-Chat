//! Function Calling Types for JSON-based Tool Calling
//!
//! This module defines types for parsing and formatting tool calls using
//! the JSON function calling format (OpenAI standard) used by Mistral and Ollama.
//!
//! These types are used by the provider adapters (MistralToolAdapter, OllamaToolAdapter)
//! to convert between API-specific formats and our internal tool execution system.
//!
//! Note: This does NOT replace our existing Tool trait or ToolDefinition.
//! The existing tool system is preserved; these types are only for API communication.

use serde::{Deserialize, Serialize};

/// Represents a function/tool call extracted from an LLM response.
///
/// This is the parsed representation of a tool_call from the provider's JSON response.
/// The format follows the OpenAI function calling standard adopted by Mistral and Ollama.
///
/// # Example JSON (Mistral response)
/// ```json
/// {
///   "id": "call_abc123",
///   "type": "function",
///   "function": {
///     "name": "MemoryTool",
///     "arguments": "{\"operation\":\"add\",\"content\":\"test\"}"
///   }
/// }
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionCall {
    /// Unique identifier for this call, generated by the provider.
    /// Mistral provides this; Ollama requires synthetic ID generation.
    pub id: String,

    /// Name of the function/tool to call.
    /// For local tools: "MemoryTool", "TodoTool"
    /// For MCP tools: "mcp__server__tool" format
    pub name: String,

    /// Parsed JSON arguments for the function call.
    /// Already deserialized from the API response.
    pub arguments: serde_json::Value,
}

#[allow(dead_code)] // Builder methods for API completeness
impl FunctionCall {
    /// Creates a new FunctionCall with the given parameters.
    pub fn new(
        id: impl Into<String>,
        name: impl Into<String>,
        arguments: serde_json::Value,
    ) -> Self {
        Self {
            id: id.into(),
            name: name.into(),
            arguments,
        }
    }

    /// Checks if this is an MCP tool call (format: mcp__server__tool).
    pub fn is_mcp_tool(&self) -> bool {
        self.name.starts_with("mcp__")
    }

    /// Extracts MCP server and tool name from the function name.
    ///
    /// # Returns
    /// `Some((server_name, tool_name))` if this is an MCP tool, `None` otherwise.
    ///
    /// # Example
    /// ```ignore
    /// let call = FunctionCall::new("id", "mcp__serena__find_symbol", json!({}));
    /// assert_eq!(call.parse_mcp_name(), Some(("serena", "find_symbol")));
    /// ```
    pub fn parse_mcp_name(&self) -> Option<(&str, &str)> {
        if !self.is_mcp_tool() {
            return None;
        }

        // Format: mcp__server__tool
        let stripped = self.name.strip_prefix("mcp__")?;
        let parts: Vec<&str> = stripped.splitn(2, "__").collect();
        if parts.len() == 2 {
            Some((parts[0], parts[1]))
        } else {
            None
        }
    }
}

/// Result of executing a function/tool call.
///
/// This is formatted and sent back to the LLM provider as a "tool" role message.
/// The format varies slightly between providers (handled by adapters).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionCallResult {
    /// Corresponds to FunctionCall.id - links result to original call.
    pub call_id: String,

    /// Name of the function that was called (for reference).
    pub function_name: String,

    /// Whether the execution succeeded.
    pub success: bool,

    /// The result data from tool execution.
    /// This is the JSON output from our Tool::execute() method.
    pub result: serde_json::Value,

    /// Error message if success is false.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,

    /// Execution time in milliseconds (for metrics).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub execution_time_ms: Option<u64>,
}

impl FunctionCallResult {
    /// Creates a successful result.
    pub fn success(
        call_id: impl Into<String>,
        function_name: impl Into<String>,
        result: serde_json::Value,
    ) -> Self {
        Self {
            call_id: call_id.into(),
            function_name: function_name.into(),
            success: true,
            result,
            error: None,
            execution_time_ms: None,
        }
    }

    /// Creates a failure result with an error message.
    pub fn failure(
        call_id: impl Into<String>,
        function_name: impl Into<String>,
        error: impl Into<String>,
    ) -> Self {
        Self {
            call_id: call_id.into(),
            function_name: function_name.into(),
            success: false,
            result: serde_json::Value::Null,
            error: Some(error.into()),
            execution_time_ms: None,
        }
    }

    /// Sets the execution time in milliseconds.
    pub fn with_execution_time(mut self, ms: u64) -> Self {
        self.execution_time_ms = Some(ms);
        self
    }
}

/// Mode for tool/function selection in API calls.
///
/// Controls how the LLM should interact with available tools.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, Default, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ToolChoiceMode {
    /// LLM decides whether to call tools or respond directly.
    #[default]
    Auto,

    /// LLM must call at least one tool.
    Required,

    /// LLM should not call any tools (respond directly).
    None,
}

#[allow(dead_code)] // Utility methods for API completeness
impl ToolChoiceMode {
    /// Converts to the string representation used by most APIs.
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::Auto => "auto",
            Self::Required => "required",
            Self::None => "none",
        }
    }
}

/// Represents a chat message in the conversation history.
///
/// This is used for building multi-turn conversations with tool calls.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "role", rename_all = "lowercase")]
pub enum ChatMessage {
    /// System message (instructions).
    System { content: String },

    /// User message.
    User { content: String },

    /// Assistant message, optionally with tool calls.
    Assistant {
        #[serde(skip_serializing_if = "Option::is_none")]
        content: Option<String>,
        #[serde(skip_serializing_if = "Option::is_none")]
        tool_calls: Option<Vec<AssistantToolCall>>,
    },

    /// Tool result message.
    Tool {
        tool_call_id: String,
        #[serde(skip_serializing_if = "Option::is_none")]
        name: Option<String>,
        content: String,
    },
}

/// Tool call structure as it appears in assistant messages.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssistantToolCall {
    /// Unique identifier for the tool call.
    pub id: String,

    /// Type of the call (always "function" for our use case).
    #[serde(rename = "type")]
    pub call_type: String,

    /// The function being called.
    pub function: AssistantToolCallFunction,
}

/// Function details within a tool call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AssistantToolCallFunction {
    /// Name of the function.
    pub name: String,

    /// Arguments as a JSON string (Mistral) or object (Ollama).
    /// We store as Value to handle both cases.
    pub arguments: serde_json::Value,
}

#[allow(dead_code)] // Builder methods for API completeness
impl ChatMessage {
    /// Creates a system message.
    pub fn system(content: impl Into<String>) -> Self {
        Self::System {
            content: content.into(),
        }
    }

    /// Creates a user message.
    pub fn user(content: impl Into<String>) -> Self {
        Self::User {
            content: content.into(),
        }
    }

    /// Creates an assistant message with text content only.
    pub fn assistant(content: impl Into<String>) -> Self {
        Self::Assistant {
            content: Some(content.into()),
            tool_calls: None,
        }
    }

    /// Creates an assistant message with tool calls.
    pub fn assistant_with_tools(
        content: Option<String>,
        tool_calls: Vec<AssistantToolCall>,
    ) -> Self {
        Self::Assistant {
            content,
            tool_calls: Some(tool_calls),
        }
    }

    /// Creates a tool result message.
    pub fn tool_result(
        call_id: impl Into<String>,
        name: Option<String>,
        content: impl Into<String>,
    ) -> Self {
        Self::Tool {
            tool_call_id: call_id.into(),
            name,
            content: content.into(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_function_call_mcp_parsing() {
        // Local tool
        let local = FunctionCall::new("call_1", "MemoryTool", json!({"operation": "add"}));
        assert!(!local.is_mcp_tool());
        assert!(local.parse_mcp_name().is_none());

        // MCP tool
        let mcp = FunctionCall::new(
            "call_2",
            "mcp__serena__find_symbol",
            json!({"pattern": "Foo"}),
        );
        assert!(mcp.is_mcp_tool());
        assert_eq!(mcp.parse_mcp_name(), Some(("serena", "find_symbol")));

        // MCP tool with underscores in name
        let mcp2 = FunctionCall::new("call_3", "mcp__context7__get_docs", json!({}));
        assert!(mcp2.is_mcp_tool());
        assert_eq!(mcp2.parse_mcp_name(), Some(("context7", "get_docs")));
    }

    #[test]
    fn test_function_call_result_builders() {
        let success =
            FunctionCallResult::success("call_1", "MemoryTool", json!({"memory_id": "123"}));
        assert!(success.success);
        assert!(success.error.is_none());

        let failure = FunctionCallResult::failure("call_2", "TodoTool", "Database error");
        assert!(!failure.success);
        assert_eq!(failure.error, Some("Database error".to_string()));

        let with_time =
            FunctionCallResult::success("call_3", "Test", json!(null)).with_execution_time(150);
        assert_eq!(with_time.execution_time_ms, Some(150));
    }

    #[test]
    fn test_tool_choice_mode() {
        assert_eq!(ToolChoiceMode::Auto.as_str(), "auto");
        assert_eq!(ToolChoiceMode::Required.as_str(), "required");
        assert_eq!(ToolChoiceMode::None.as_str(), "none");

        // Test default
        assert_eq!(ToolChoiceMode::default(), ToolChoiceMode::Auto);
    }

    #[test]
    fn test_chat_message_serialization() {
        let system = ChatMessage::system("You are helpful");
        let json = serde_json::to_value(&system).unwrap();
        assert_eq!(json["role"], "system");
        assert_eq!(json["content"], "You are helpful");

        let user = ChatMessage::user("Hello");
        let json = serde_json::to_value(&user).unwrap();
        assert_eq!(json["role"], "user");

        let tool = ChatMessage::tool_result(
            "call_1",
            Some("MemoryTool".to_string()),
            r#"{"success": true}"#,
        );
        let json = serde_json::to_value(&tool).unwrap();
        assert_eq!(json["role"], "tool");
        assert_eq!(json["tool_call_id"], "call_1");
    }
}
