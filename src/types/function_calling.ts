/**
 * Copyright 2025 Assistance Micro Design
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Function Calling Types for JSON-based Tool Calling
 *
 * Types for parsing and formatting tool calls using the JSON function calling
 * format (OpenAI standard) used by Mistral and Ollama APIs.
 *
 * These types mirror the Rust types in src-tauri/src/models/function_calling.rs
 * and are used for frontend display of tool execution (if needed).
 *
 * @module function_calling
 */

/**
 * Represents a function/tool call extracted from an LLM response.
 *
 * This is the parsed representation of a tool_call from the provider's JSON response.
 * The format follows the OpenAI function calling standard adopted by Mistral and Ollama.
 *
 * @example
 * ```typescript
 * const call: FunctionCall = {
 *   id: "call_abc123",
 *   name: "MemoryTool",
 *   arguments: { operation: "add", content: "Remember this" }
 * };
 * ```
 */
export interface FunctionCall {
  /** Unique identifier for this call, generated by the provider */
  id: string;
  /**
   * Name of the function/tool to call.
   * - Local tools: "MemoryTool", "TodoTool"
   * - MCP tools: "mcp__server__tool" format
   */
  name: string;
  /** Parsed JSON arguments for the function call */
  arguments: Record<string, unknown>;
}

/**
 * Result of executing a function/tool call.
 *
 * This is formatted and sent back to the LLM provider as a "tool" role message.
 */
export interface FunctionCallResult {
  /** Corresponds to FunctionCall.id - links result to original call */
  call_id: string;
  /** Name of the function that was called (for reference) */
  function_name: string;
  /** Whether the execution succeeded */
  success: boolean;
  /** The result data from tool execution */
  result: unknown;
  /** Error message if success is false */
  error?: string;
  /** Execution time in milliseconds (for metrics) */
  execution_time_ms?: number;
}

/**
 * Mode for tool/function selection in API calls.
 * Controls how the LLM should interact with available tools.
 */
export type ToolChoiceMode = 'auto' | 'required' | 'none';

/**
 * Tool definition in OpenAI/Mistral function calling format.
 * Used when sending available tools to the API.
 */
export interface ToolDefinitionAPI {
  type: 'function';
  function: {
    name: string;
    description: string;
    parameters: {
      type: 'object';
      properties: Record<string, unknown>;
      required?: string[];
    };
  };
}

/**
 * Chat message in conversation history.
 * Used for building multi-turn conversations with tool calls.
 */
export type ChatMessage =
  | SystemMessage
  | UserMessage
  | AssistantMessage
  | ToolMessage;

/** System message (instructions) */
export interface SystemMessage {
  role: 'system';
  content: string;
}

/** User message */
export interface UserMessage {
  role: 'user';
  content: string;
}

/** Assistant message, optionally with tool calls */
export interface AssistantMessage {
  role: 'assistant';
  content?: string;
  tool_calls?: AssistantToolCall[];
}

/** Tool result message */
export interface ToolMessage {
  role: 'tool';
  tool_call_id: string;
  name?: string;
  content: string;
}

/**
 * Tool call structure as it appears in assistant messages.
 */
export interface AssistantToolCall {
  /** Unique identifier for the tool call */
  id: string;
  /** Type of the call (always "function" for our use case) */
  type: 'function';
  /** The function being called */
  function: {
    name: string;
    /** Arguments as JSON string (Mistral) or object (Ollama) */
    arguments: string | Record<string, unknown>;
  };
}

/**
 * Helper functions for working with function calls
 */
export const FunctionCallHelpers = {
  /**
   * Checks if a function call is an MCP tool.
   * MCP tools follow the format: mcp__server__tool
   */
  isMcpTool(name: string): boolean {
    return name.startsWith('mcp__');
  },

  /**
   * Parses MCP server and tool name from the function name.
   * @returns [serverName, toolName] or null if not an MCP tool
   */
  parseMcpName(name: string): [string, string] | null {
    if (!this.isMcpTool(name)) return null;

    const stripped = name.slice(5); // Remove "mcp__"
    const parts = stripped.split('__');
    if (parts.length >= 2) {
      return [parts[0], parts.slice(1).join('__')];
    }
    return null;
  },

  /**
   * Creates a successful function call result.
   */
  successResult(
    callId: string,
    functionName: string,
    result: unknown
  ): FunctionCallResult {
    return {
      call_id: callId,
      function_name: functionName,
      success: true,
      result,
    };
  },

  /**
   * Creates a failure function call result.
   */
  failureResult(
    callId: string,
    functionName: string,
    error: string
  ): FunctionCallResult {
    return {
      call_id: callId,
      function_name: functionName,
      success: false,
      result: null,
      error,
    };
  },
};
